/*
 * Amazon DynamoDB
 * <fullname>Amazon DynamoDB</fullname> <p>Amazon DynamoDB is a fully managed NoSQL database service that provides fast and predictable performance with seamless scalability. DynamoDB lets you offload the administrative burdens of operating and scaling a distributed database, so that you don't have to worry about hardware provisioning, setup and configuration, replication, software patching, or cluster scaling.</p> <p>With DynamoDB, you can create database tables that can store and retrieve any amount of data, and serve any level of request traffic. You can scale up or scale down your tables' throughput capacity without downtime or performance degradation, and use the Amazon Web Services Management Console to monitor resource utilization and performance metrics.</p> <p>DynamoDB automatically spreads the data and traffic for your tables over a sufficient number of servers to handle your throughput and storage requirements, while maintaining consistent and fast performance. All of your data is stored on solid state disks (SSDs) and automatically replicated across multiple Availability Zones in an Amazon Web Services Region, providing built-in high availability and data durability.</p>
 *
 * The version of the OpenAPI document: 2012-08-10
 * Contact: mike.ralphson@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.AttributeDefinition;
import org.openapitools.client.model.BillingMode;
import org.openapitools.client.model.GlobalSecondaryIndexUpdate;
import org.openapitools.client.model.ProvisionedThroughput;
import org.openapitools.client.model.ReplicationGroupUpdate;
import org.openapitools.client.model.SSESpecification;
import org.openapitools.client.model.StreamSpecification;
import org.openapitools.client.model.TableClass;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Represents the input of an &lt;code&gt;UpdateTable&lt;/code&gt; operation.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-25T14:20:21.724079+05:30[Asia/Kolkata]", comments = "Generator version: 7.15.0")
public class UpdateTableInput {
  public static final String SERIALIZED_NAME_ATTRIBUTE_DEFINITIONS = "AttributeDefinitions";
  @SerializedName(SERIALIZED_NAME_ATTRIBUTE_DEFINITIONS)
  @javax.annotation.Nullable
  private List<AttributeDefinition> attributeDefinitions;

  public static final String SERIALIZED_NAME_TABLE_NAME = "TableName";
  @SerializedName(SERIALIZED_NAME_TABLE_NAME)
  @javax.annotation.Nonnull
  private String tableName;

  public static final String SERIALIZED_NAME_BILLING_MODE = "BillingMode";
  @SerializedName(SERIALIZED_NAME_BILLING_MODE)
  @javax.annotation.Nullable
  private BillingMode billingMode;

  public static final String SERIALIZED_NAME_PROVISIONED_THROUGHPUT = "ProvisionedThroughput";
  @SerializedName(SERIALIZED_NAME_PROVISIONED_THROUGHPUT)
  @javax.annotation.Nullable
  private ProvisionedThroughput provisionedThroughput;

  public static final String SERIALIZED_NAME_GLOBAL_SECONDARY_INDEX_UPDATES = "GlobalSecondaryIndexUpdates";
  @SerializedName(SERIALIZED_NAME_GLOBAL_SECONDARY_INDEX_UPDATES)
  @javax.annotation.Nullable
  private List<GlobalSecondaryIndexUpdate> globalSecondaryIndexUpdates;

  public static final String SERIALIZED_NAME_STREAM_SPECIFICATION = "StreamSpecification";
  @SerializedName(SERIALIZED_NAME_STREAM_SPECIFICATION)
  @javax.annotation.Nullable
  private StreamSpecification streamSpecification;

  public static final String SERIALIZED_NAME_SS_E_SPECIFICATION = "SSESpecification";
  @SerializedName(SERIALIZED_NAME_SS_E_SPECIFICATION)
  @javax.annotation.Nullable
  private SSESpecification ssESpecification;

  public static final String SERIALIZED_NAME_REPLICA_UPDATES = "ReplicaUpdates";
  @SerializedName(SERIALIZED_NAME_REPLICA_UPDATES)
  @javax.annotation.Nullable
  private List<ReplicationGroupUpdate> replicaUpdates;

  public static final String SERIALIZED_NAME_TABLE_CLASS = "TableClass";
  @SerializedName(SERIALIZED_NAME_TABLE_CLASS)
  @javax.annotation.Nullable
  private TableClass tableClass;

  public static final String SERIALIZED_NAME_DELETION_PROTECTION_ENABLED = "DeletionProtectionEnabled";
  @SerializedName(SERIALIZED_NAME_DELETION_PROTECTION_ENABLED)
  @javax.annotation.Nullable
  private Boolean deletionProtectionEnabled;

  public UpdateTableInput() {
  }

  public UpdateTableInput attributeDefinitions(@javax.annotation.Nullable List<AttributeDefinition> attributeDefinitions) {
    this.attributeDefinitions = attributeDefinitions;
    return this;
  }

  public UpdateTableInput addAttributeDefinitionsItem(AttributeDefinition attributeDefinitionsItem) {
    if (this.attributeDefinitions == null) {
      this.attributeDefinitions = new ArrayList<>();
    }
    this.attributeDefinitions.add(attributeDefinitionsItem);
    return this;
  }

  /**
   * An array of attributes that describe the key schema for the table and indexes. If you are adding a new global secondary index to the table, &lt;code&gt;AttributeDefinitions&lt;/code&gt; must include the key element(s) of the new index.
   * @return attributeDefinitions
   */
  @javax.annotation.Nullable
  public List<AttributeDefinition> getAttributeDefinitions() {
    return attributeDefinitions;
  }

  public void setAttributeDefinitions(@javax.annotation.Nullable List<AttributeDefinition> attributeDefinitions) {
    this.attributeDefinitions = attributeDefinitions;
  }


  public UpdateTableInput tableName(@javax.annotation.Nonnull String tableName) {
    this.tableName = tableName;
    return this;
  }

  /**
   * The name of the table to be updated.
   * @return tableName
   */
  @javax.annotation.Nonnull
  public String getTableName() {
    return tableName;
  }

  public void setTableName(@javax.annotation.Nonnull String tableName) {
    this.tableName = tableName;
  }


  public UpdateTableInput billingMode(@javax.annotation.Nullable BillingMode billingMode) {
    this.billingMode = billingMode;
    return this;
  }

  /**
   * &lt;p&gt;Controls how you are charged for read and write throughput and how you manage capacity. When switching from pay-per-request to provisioned capacity, initial provisioned capacity values must be set. The initial provisioned capacity values are estimated based on the consumed read and write capacity of your table and global secondary indexes over the past 30 minutes.&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;PROVISIONED&lt;/code&gt; - We recommend using &lt;code&gt;PROVISIONED&lt;/code&gt; for predictable workloads. &lt;code&gt;PROVISIONED&lt;/code&gt; sets the billing mode to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.ProvisionedThroughput.Manual\&quot;&gt;Provisioned Mode&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;PAY_PER_REQUEST&lt;/code&gt; - We recommend using &lt;code&gt;PAY_PER_REQUEST&lt;/code&gt; for unpredictable workloads. &lt;code&gt;PAY_PER_REQUEST&lt;/code&gt; sets the billing mode to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.OnDemand\&quot;&gt;On-Demand Mode&lt;/a&gt;. &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
   * @return billingMode
   */
  @javax.annotation.Nullable
  public BillingMode getBillingMode() {
    return billingMode;
  }

  public void setBillingMode(@javax.annotation.Nullable BillingMode billingMode) {
    this.billingMode = billingMode;
  }


  public UpdateTableInput provisionedThroughput(@javax.annotation.Nullable ProvisionedThroughput provisionedThroughput) {
    this.provisionedThroughput = provisionedThroughput;
    return this;
  }

  /**
   * The new provisioned throughput settings for the specified table or index.
   * @return provisionedThroughput
   */
  @javax.annotation.Nullable
  public ProvisionedThroughput getProvisionedThroughput() {
    return provisionedThroughput;
  }

  public void setProvisionedThroughput(@javax.annotation.Nullable ProvisionedThroughput provisionedThroughput) {
    this.provisionedThroughput = provisionedThroughput;
  }


  public UpdateTableInput globalSecondaryIndexUpdates(@javax.annotation.Nullable List<GlobalSecondaryIndexUpdate> globalSecondaryIndexUpdates) {
    this.globalSecondaryIndexUpdates = globalSecondaryIndexUpdates;
    return this;
  }

  public UpdateTableInput addGlobalSecondaryIndexUpdatesItem(GlobalSecondaryIndexUpdate globalSecondaryIndexUpdatesItem) {
    if (this.globalSecondaryIndexUpdates == null) {
      this.globalSecondaryIndexUpdates = new ArrayList<>();
    }
    this.globalSecondaryIndexUpdates.add(globalSecondaryIndexUpdatesItem);
    return this;
  }

  /**
   * &lt;p&gt;An array of one or more global secondary indexes for the table. For each index in the array, you can request one action:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;Create&lt;/code&gt; - add a new global secondary index to the table.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;Update&lt;/code&gt; - modify the provisioned throughput settings of an existing global secondary index.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;Delete&lt;/code&gt; - remove a global secondary index from the table.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;You can create or delete only one global secondary index per &lt;code&gt;UpdateTable&lt;/code&gt; operation.&lt;/p&gt; &lt;p&gt;For more information, see &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.OnlineOps.html\&quot;&gt;Managing Global Secondary Indexes&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;. &lt;/p&gt;
   * @return globalSecondaryIndexUpdates
   */
  @javax.annotation.Nullable
  public List<GlobalSecondaryIndexUpdate> getGlobalSecondaryIndexUpdates() {
    return globalSecondaryIndexUpdates;
  }

  public void setGlobalSecondaryIndexUpdates(@javax.annotation.Nullable List<GlobalSecondaryIndexUpdate> globalSecondaryIndexUpdates) {
    this.globalSecondaryIndexUpdates = globalSecondaryIndexUpdates;
  }


  public UpdateTableInput streamSpecification(@javax.annotation.Nullable StreamSpecification streamSpecification) {
    this.streamSpecification = streamSpecification;
    return this;
  }

  /**
   * &lt;p&gt;Represents the DynamoDB Streams configuration for the table.&lt;/p&gt; &lt;note&gt; &lt;p&gt;You receive a &lt;code&gt;ResourceInUseException&lt;/code&gt; if you try to enable a stream on a table that already has a stream, or if you try to disable a stream on a table that doesn&#39;t have a stream.&lt;/p&gt; &lt;/note&gt;
   * @return streamSpecification
   */
  @javax.annotation.Nullable
  public StreamSpecification getStreamSpecification() {
    return streamSpecification;
  }

  public void setStreamSpecification(@javax.annotation.Nullable StreamSpecification streamSpecification) {
    this.streamSpecification = streamSpecification;
  }


  public UpdateTableInput ssESpecification(@javax.annotation.Nullable SSESpecification ssESpecification) {
    this.ssESpecification = ssESpecification;
    return this;
  }

  /**
   * The new server-side encryption settings for the specified table.
   * @return ssESpecification
   */
  @javax.annotation.Nullable
  public SSESpecification getSsESpecification() {
    return ssESpecification;
  }

  public void setSsESpecification(@javax.annotation.Nullable SSESpecification ssESpecification) {
    this.ssESpecification = ssESpecification;
  }


  public UpdateTableInput replicaUpdates(@javax.annotation.Nullable List<ReplicationGroupUpdate> replicaUpdates) {
    this.replicaUpdates = replicaUpdates;
    return this;
  }

  public UpdateTableInput addReplicaUpdatesItem(ReplicationGroupUpdate replicaUpdatesItem) {
    if (this.replicaUpdates == null) {
      this.replicaUpdates = new ArrayList<>();
    }
    this.replicaUpdates.add(replicaUpdatesItem);
    return this;
  }

  /**
   * &lt;p&gt;A list of replica update actions (create, delete, or update) for the table.&lt;/p&gt; &lt;note&gt; &lt;p&gt;This property only applies to &lt;a href&#x3D;\&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html\&quot;&gt;Version 2019.11.21 (Current)&lt;/a&gt; of global tables. &lt;/p&gt; &lt;/note&gt;
   * @return replicaUpdates
   */
  @javax.annotation.Nullable
  public List<ReplicationGroupUpdate> getReplicaUpdates() {
    return replicaUpdates;
  }

  public void setReplicaUpdates(@javax.annotation.Nullable List<ReplicationGroupUpdate> replicaUpdates) {
    this.replicaUpdates = replicaUpdates;
  }


  public UpdateTableInput tableClass(@javax.annotation.Nullable TableClass tableClass) {
    this.tableClass = tableClass;
    return this;
  }

  /**
   * The table class of the table to be updated. Valid values are &lt;code&gt;STANDARD&lt;/code&gt; and &lt;code&gt;STANDARD_INFREQUENT_ACCESS&lt;/code&gt;.
   * @return tableClass
   */
  @javax.annotation.Nullable
  public TableClass getTableClass() {
    return tableClass;
  }

  public void setTableClass(@javax.annotation.Nullable TableClass tableClass) {
    this.tableClass = tableClass;
  }


  public UpdateTableInput deletionProtectionEnabled(@javax.annotation.Nullable Boolean deletionProtectionEnabled) {
    this.deletionProtectionEnabled = deletionProtectionEnabled;
    return this;
  }

  /**
   * Indicates whether deletion protection is to be enabled (true) or disabled (false) on the table.
   * @return deletionProtectionEnabled
   */
  @javax.annotation.Nullable
  public Boolean getDeletionProtectionEnabled() {
    return deletionProtectionEnabled;
  }

  public void setDeletionProtectionEnabled(@javax.annotation.Nullable Boolean deletionProtectionEnabled) {
    this.deletionProtectionEnabled = deletionProtectionEnabled;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    UpdateTableInput updateTableInput = (UpdateTableInput) o;
    return Objects.equals(this.attributeDefinitions, updateTableInput.attributeDefinitions) &&
        Objects.equals(this.tableName, updateTableInput.tableName) &&
        Objects.equals(this.billingMode, updateTableInput.billingMode) &&
        Objects.equals(this.provisionedThroughput, updateTableInput.provisionedThroughput) &&
        Objects.equals(this.globalSecondaryIndexUpdates, updateTableInput.globalSecondaryIndexUpdates) &&
        Objects.equals(this.streamSpecification, updateTableInput.streamSpecification) &&
        Objects.equals(this.ssESpecification, updateTableInput.ssESpecification) &&
        Objects.equals(this.replicaUpdates, updateTableInput.replicaUpdates) &&
        Objects.equals(this.tableClass, updateTableInput.tableClass) &&
        Objects.equals(this.deletionProtectionEnabled, updateTableInput.deletionProtectionEnabled);
  }

  @Override
  public int hashCode() {
    return Objects.hash(attributeDefinitions, tableName, billingMode, provisionedThroughput, globalSecondaryIndexUpdates, streamSpecification, ssESpecification, replicaUpdates, tableClass, deletionProtectionEnabled);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class UpdateTableInput {\n");
    sb.append("    attributeDefinitions: ").append(toIndentedString(attributeDefinitions)).append("\n");
    sb.append("    tableName: ").append(toIndentedString(tableName)).append("\n");
    sb.append("    billingMode: ").append(toIndentedString(billingMode)).append("\n");
    sb.append("    provisionedThroughput: ").append(toIndentedString(provisionedThroughput)).append("\n");
    sb.append("    globalSecondaryIndexUpdates: ").append(toIndentedString(globalSecondaryIndexUpdates)).append("\n");
    sb.append("    streamSpecification: ").append(toIndentedString(streamSpecification)).append("\n");
    sb.append("    ssESpecification: ").append(toIndentedString(ssESpecification)).append("\n");
    sb.append("    replicaUpdates: ").append(toIndentedString(replicaUpdates)).append("\n");
    sb.append("    tableClass: ").append(toIndentedString(tableClass)).append("\n");
    sb.append("    deletionProtectionEnabled: ").append(toIndentedString(deletionProtectionEnabled)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>(Arrays.asList("AttributeDefinitions", "TableName", "BillingMode", "ProvisionedThroughput", "GlobalSecondaryIndexUpdates", "StreamSpecification", "SSESpecification", "ReplicaUpdates", "TableClass", "DeletionProtectionEnabled"));

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>(Arrays.asList("TableName"));
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to UpdateTableInput
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!UpdateTableInput.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in UpdateTableInput is not found in the empty JSON string", UpdateTableInput.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!UpdateTableInput.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `UpdateTableInput` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : UpdateTableInput.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("AttributeDefinitions") != null && !jsonObj.get("AttributeDefinitions").isJsonNull()) {
        JsonArray jsonArrayattributeDefinitions = jsonObj.getAsJsonArray("AttributeDefinitions");
        if (jsonArrayattributeDefinitions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("AttributeDefinitions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `AttributeDefinitions` to be an array in the JSON string but got `%s`", jsonObj.get("AttributeDefinitions").toString()));
          }

          // validate the optional field `AttributeDefinitions` (array)
          for (int i = 0; i < jsonArrayattributeDefinitions.size(); i++) {
            AttributeDefinition.validateJsonElement(jsonArrayattributeDefinitions.get(i));
          };
        }
      }
      if (!jsonObj.get("TableName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `TableName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("TableName").toString()));
      }
      // validate the optional field `BillingMode`
      if (jsonObj.get("BillingMode") != null && !jsonObj.get("BillingMode").isJsonNull()) {
        BillingMode.validateJsonElement(jsonObj.get("BillingMode"));
      }
      // validate the optional field `ProvisionedThroughput`
      if (jsonObj.get("ProvisionedThroughput") != null && !jsonObj.get("ProvisionedThroughput").isJsonNull()) {
        ProvisionedThroughput.validateJsonElement(jsonObj.get("ProvisionedThroughput"));
      }
      if (jsonObj.get("GlobalSecondaryIndexUpdates") != null && !jsonObj.get("GlobalSecondaryIndexUpdates").isJsonNull()) {
        JsonArray jsonArrayglobalSecondaryIndexUpdates = jsonObj.getAsJsonArray("GlobalSecondaryIndexUpdates");
        if (jsonArrayglobalSecondaryIndexUpdates != null) {
          // ensure the json data is an array
          if (!jsonObj.get("GlobalSecondaryIndexUpdates").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `GlobalSecondaryIndexUpdates` to be an array in the JSON string but got `%s`", jsonObj.get("GlobalSecondaryIndexUpdates").toString()));
          }

          // validate the optional field `GlobalSecondaryIndexUpdates` (array)
          for (int i = 0; i < jsonArrayglobalSecondaryIndexUpdates.size(); i++) {
            GlobalSecondaryIndexUpdate.validateJsonElement(jsonArrayglobalSecondaryIndexUpdates.get(i));
          };
        }
      }
      // validate the optional field `StreamSpecification`
      if (jsonObj.get("StreamSpecification") != null && !jsonObj.get("StreamSpecification").isJsonNull()) {
        StreamSpecification.validateJsonElement(jsonObj.get("StreamSpecification"));
      }
      // validate the optional field `SSESpecification`
      if (jsonObj.get("SSESpecification") != null && !jsonObj.get("SSESpecification").isJsonNull()) {
        SSESpecification.validateJsonElement(jsonObj.get("SSESpecification"));
      }
      if (jsonObj.get("ReplicaUpdates") != null && !jsonObj.get("ReplicaUpdates").isJsonNull()) {
        JsonArray jsonArrayreplicaUpdates = jsonObj.getAsJsonArray("ReplicaUpdates");
        if (jsonArrayreplicaUpdates != null) {
          // ensure the json data is an array
          if (!jsonObj.get("ReplicaUpdates").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `ReplicaUpdates` to be an array in the JSON string but got `%s`", jsonObj.get("ReplicaUpdates").toString()));
          }

          // validate the optional field `ReplicaUpdates` (array)
          for (int i = 0; i < jsonArrayreplicaUpdates.size(); i++) {
            ReplicationGroupUpdate.validateJsonElement(jsonArrayreplicaUpdates.get(i));
          };
        }
      }
      // validate the optional field `TableClass`
      if (jsonObj.get("TableClass") != null && !jsonObj.get("TableClass").isJsonNull()) {
        TableClass.validateJsonElement(jsonObj.get("TableClass"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!UpdateTableInput.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'UpdateTableInput' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<UpdateTableInput> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(UpdateTableInput.class));

       return (TypeAdapter<T>) new TypeAdapter<UpdateTableInput>() {
           @Override
           public void write(JsonWriter out, UpdateTableInput value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public UpdateTableInput read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of UpdateTableInput given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of UpdateTableInput
   * @throws IOException if the JSON string is invalid with respect to UpdateTableInput
   */
  public static UpdateTableInput fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, UpdateTableInput.class);
  }

  /**
   * Convert an instance of UpdateTableInput to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

